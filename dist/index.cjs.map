{"version":3,"file":"index.cjs","sources":["../src/core/managers/FunctionManager.tsx","../src/core/setter/setFun.ts","../src/core/setter/set.ts","../src/core/managers/EffectManager.tsx","../src/core/Reducers.tsx","../src/core/Dispatcher.tsx","../src/core/useThis/useThisInstance.tsx","../src/core/useThis/useThis.ts"],"sourcesContent":["type FunctionStore = {\r\n  [key: string]: Function;\r\n};\r\n\r\nconst function_collection: FunctionStore = {};\r\nlet functionIdCounter = 0;\r\n\r\nexport let FunctionManager = {\r\n  collection: {},\r\n} as {\r\n  collection: {\r\n    store: (func: Function) => string;\r\n    retrive: (id: string) => Function;\r\n    get: Object;\r\n  };\r\n  store: (obj: unknown) => unknown;\r\n  fetch: (obj: Object) => Object;\r\n};\r\n\r\nFunctionManager.collection.store = (func: Function) => {\r\n  const id = `__func_${functionIdCounter++}__`;\r\n  function_collection[id] = func;\r\n\r\n  return id;\r\n};\r\nFunctionManager.collection.retrive = (id: string) => {\r\n  return function_collection[id];\r\n};\r\nFunctionManager.collection.get = () => {\r\n  return function_collection;\r\n};\r\n\r\nFunctionManager.store = (obj: any): any => {\r\n  if (typeof obj === \"function\") {\r\n    return FunctionManager.collection.store(obj);\r\n  } else if (Array.isArray(obj)) {\r\n    return obj.map(FunctionManager.store);\r\n  } else if (obj !== null && typeof obj === \"object\") {\r\n    return Object.keys(obj).reduce((acc, key) => {\r\n      acc[key] = FunctionManager.store(obj[key]);\r\n      return acc;\r\n    }, {} as any);\r\n  }\r\n  return obj;\r\n};\r\n\r\nFunctionManager.fetch = (obj: Object): Object => {\r\n  if (\r\n    typeof obj === \"string\" &&\r\n    obj.startsWith(\"__func_\") &&\r\n    obj.endsWith(\"__\")\r\n  ) {\r\n    return FunctionManager.collection.retrive(obj);\r\n  } else if (Array.isArray(obj)) {\r\n    return obj.map(FunctionManager.fetch);\r\n  } else if (obj !== null && typeof obj === \"object\") {\r\n    return Object.keys(obj).reduce<{ [key: string]: Object }>((acc, key) => {\r\n      //@ts-ignore\r\n      acc[key] = FunctionManager.fetch(obj[key]);\r\n      return acc;\r\n    }, {});\r\n  }\r\n  return obj;\r\n};\r\n","import { set } from \"js-upsert\";\r\nimport { FunctionManager } from \"../managers/FunctionManager\";\r\n\r\nexport function setFun<T>(value: T) {\r\n  return set<T>(() => FunctionManager.store(value) as T);\r\n}\r\n","import { set as jsSet } from \"js-upsert\";\r\nimport { setFun } from \"./setFun\";\r\nimport { setType } from \"./setType\";\r\n\r\nexport const set: setType = jsSet as unknown as setType;\r\n\r\nset.fun = setFun;\r\n","import { useThis_Instance } from \"../useThis/useThisTypes\";\r\n\r\n/*\r\n\r\n\r\n  useThis-Effect\r\n\r\n  Idea: Execute a function on change of state\r\n\r\n  Initialization Flow:-\r\n\r\n  1. UseThis Dispatcher providing a reducer `EffectReducer` to useThis\r\n  2. On Initialisation of useThis(state_name) having a effect(effect_fun, dependent_state), effect is getting registered at a `effect_collection` \r\n  \r\n\r\n  Working Flow:-\r\n\r\n  All state dispatchers are having hook `executeEffects` to execute effect which is having dependency of current state. \r\n\r\n\r\n*/\r\nconst effect_collection: {\r\n  dependent_state: {\r\n    [state_id: string]: string[];\r\n  };\r\n  effects: {\r\n    [process_id: string]: Function;\r\n  };\r\n  registeredStates: { [state_name: string]: boolean };\r\n  registeredProcess: { [process_id: number]: string };\r\n  resolved: { [state_name: string]: boolean };\r\n  registeredDependency: { [state_name: string]: string[] };\r\n} = {\r\n  dependent_state: {},\r\n  effects: {},\r\n  registeredStates: {},\r\n  resolved: {},\r\n  registeredProcess: {},\r\n  registeredDependency: {},\r\n};\r\n\r\n/**\r\n *\r\n * @param props\r\n * @param props.state_name State name which is dispatching a effect fn\r\n * @param props.dependent_state_names Names of state which will execute effect fn on change\r\n * @param props.effect Effect Fn provided by user\r\n * @returns\r\n */\r\n\r\nexport function registerEffect(props: {\r\n  state_name: string;\r\n  effect: Function;\r\n  dependent_state_names: (string | useThis_Instance<unknown>)[];\r\n}) {\r\n  const { state_name, effect, dependent_state_names } = props;\r\n\r\n  if (\r\n    !Array.isArray(dependent_state_names) ||\r\n    dependent_state_names.length === 0\r\n  )\r\n    throw TypeError(\r\n      \"Second parameter of effect `dependent_states` must be a non-empty array.\"\r\n    );\r\n\r\n  // Check if state is already registered its effect or not\r\n\r\n  if (effect_collection.registeredStates?.[state_name]) return;\r\n\r\n  // Register a statename, to prevent re-rendering on next load\r\n\r\n  const process_id = state_name;\r\n\r\n  // Register proccess and state\r\n  effect_collection.registeredStates[state_name] = true;\r\n\r\n  // Iterate `dependent_state_names` and execute effects of each states\r\n\r\n  for (let dependent_state of dependent_state_names) {\r\n    if (\r\n      typeof dependent_state == \"function\" &&\r\n      //@ts-ignore\r\n      dependent_state?.[\"@___usethis\"] &&\r\n      dependent_state?.[\"this\"]\r\n    ) {\r\n      dependent_state = dependent_state[\"this\"];\r\n    }\r\n    if (typeof dependent_state === \"string\") {\r\n      // Verifing If dependent state registerd in collection or not, And appending new process_id to dependent_state\r\n\r\n      if (effect_collection.dependent_state?.[dependent_state]) {\r\n        effect_collection.dependent_state[dependent_state] = [\r\n          ...effect_collection.dependent_state[dependent_state],\r\n          process_id,\r\n        ];\r\n      } else {\r\n        effect_collection.dependent_state[dependent_state] = [process_id];\r\n      }\r\n\r\n      // Store decoded dependent state\r\n      effect_collection.registeredDependency[state_name] = [\r\n        ...(effect_collection.registeredDependency[state_name] ?? []),\r\n        dependent_state,\r\n      ];\r\n    } else {\r\n      throw TypeError(\r\n        \"Invalid type passed on `dependent_states`, Only string and useThis instance supported \"\r\n      );\r\n    }\r\n\r\n    // Storing effect fun in effects collection via process_id\r\n\r\n    effect_collection.effects[process_id] = effect;\r\n  }\r\n\r\n  // effect(() => deleteEffect({ state_name }));\r\n  // console.log(effect_collection);\r\n}\r\n\r\n/*\r\n  ExecuteEffects is a dispatch hook, whenver dispatch fired, executeEffects fired after it.\r\n  It re-executes fired-state's all assigned processes\r\n*/\r\nexport function executeEffects(state_name: string) {\r\n  // Check if state is having any assigned effects or not\r\n\r\n  if (effect_collection.dependent_state?.[state_name]) {\r\n    // Execute all assigned process\r\n    for (const process_id of effect_collection.dependent_state[state_name]) {\r\n      try {\r\n        //  Executing the process function associated with process_id and passing resolveEffect\r\n        effect_collection.effects[process_id](() =>\r\n          resolveEffect({\r\n            dependent_state_name: state_name, // State which is dependent to process_id\r\n            state_name: process_id,\r\n          })\r\n        );\r\n      } catch (e) {\r\n        // Handle the error\r\n      }\r\n    }\r\n  }\r\n}\r\nexport function resolveEffect(props: {\r\n  dependent_state_name: string;\r\n  state_name: string;\r\n}) {\r\n  const { dependent_state_name, state_name } = props;\r\n  effect_collection.dependent_state[dependent_state_name] =\r\n    effect_collection.dependent_state[dependent_state_name].filter(\r\n      (item) => item !== state_name\r\n    );\r\n\r\n  delete effect_collection.effects[state_name];\r\n\r\n  effect_collection.resolved[state_name] = true;\r\n}\r\nexport function deleteEffect(props: { state_name: string }) {\r\n  let { state_name } = props;\r\n\r\n  // Iterate all registered process and remove states from dependency\r\n  for (let dependent_state of effect_collection.registeredDependency[\r\n    state_name\r\n  ]) {\r\n    effect_collection.dependent_state[dependent_state] =\r\n      effect_collection.dependent_state[dependent_state].filter(\r\n        (state) => state !== state_name\r\n      );\r\n  }\r\n  delete effect_collection.effects[state_name];\r\n  effect_collection.resolved[state_name] = true;\r\n}\r\n\r\nexport function getEffects() {\r\n  return effect_collection;\r\n}\r\n","import { StateHandler } from \"../redux/slices/StateReducer\";\r\nimport _MAINSTORE, { StoreState } from \"../redux/store\";\r\nimport { useThisReturnType } from \"./useThis/useThisTypes\";\r\nimport { FunctionManager } from \"./managers/FunctionManager\";\r\n\r\n/*\r\n\r\n  These are reducers of useThis, for dispatching updating a state\r\n\r\n*/\r\n\r\nexport function Updater(StateName: keyof StoreState[\"This\"], dispatcher: any) {\r\n  return function update(data: any) {\r\n    let __DATA =\r\n      typeof data == \"function\"\r\n        ? data(_MAINSTORE.getState().This[StateName])\r\n        : data;\r\n\r\n    dispatcher(\r\n      StateHandler.update({\r\n        data: __DATA,\r\n        state: StateName,\r\n      })\r\n    );\r\n    return _MAINSTORE.getState().This[StateName];\r\n  };\r\n}\r\n\r\nexport function Appender(\r\n  StateName: keyof StoreState[\"This\"],\r\n  dispatcher: any\r\n): useThisReturnType<keyof StoreState[\"This\"]>[\"append\"] {\r\n  return function append(data) {\r\n    let __DATA =\r\n      typeof data == \"function\"\r\n        ? data(_MAINSTORE.getState().This[StateName])\r\n        : data;\r\n    dispatcher(\r\n      StateHandler.append({\r\n        data: __DATA,\r\n        state: StateName,\r\n      })\r\n    );\r\n    return _MAINSTORE.getState().This[StateName];\r\n  };\r\n}\r\n\r\nexport function Upsert(StateName: keyof StoreState[\"This\"], dispatcher: any) {\r\n  function updater(data: any) {\r\n    try {\r\n      dispatcher(\r\n        StateHandler.upsert({\r\n          data,\r\n          type: \"general\",\r\n          active_state: StateName,\r\n          config: {},\r\n        })\r\n      );\r\n    } catch (e) {\r\n      console.log(e);\r\n    }\r\n  }\r\n\r\n  const upsert = (\r\n    ...data: any\r\n  ): useThisReturnType<keyof StoreState[\"This\"]>[\"upsert\"] => {\r\n    for (let i of data) {\r\n      updater(i);\r\n    }\r\n    return _MAINSTORE.getState().This[StateName];\r\n  };\r\n\r\n  upsert.at = (...keys: [...(string | number)[], unknown]) => {\r\n    dispatcher(\r\n      StateHandler.upsert({\r\n        data: keys,\r\n        active_state: StateName,\r\n        config: {},\r\n        type: \"at\",\r\n      })\r\n    );\r\n    return _MAINSTORE.getState().This[StateName];\r\n  };\r\n  upsert.funAt = (...keys: [...(string | number)[], void]) => {\r\n    const value = FunctionManager.store(keys[keys.length - 1]);\r\n\r\n    keys.pop();\r\n\r\n    const new_at_path = [...keys, value];\r\n    dispatcher(\r\n      StateHandler.upsert({\r\n        data: new_at_path,\r\n        active_state: StateName,\r\n        config: {},\r\n        type: \"at\",\r\n      })\r\n    );\r\n    return _MAINSTORE.getState().This[StateName];\r\n  };\r\n\r\n  return upsert;\r\n}\r\n","import { StateHandler } from \"../redux/slices/StateReducer\";\r\nimport _MAINSTORE, { StoreState } from \"../redux/store\";\r\nimport { useThisReturnType } from \"./useThis/useThisTypes\";\r\nimport { executeEffects, getEffects } from \"./managers/EffectManager\";\r\nimport { FunctionManager } from \"./managers/FunctionManager\";\r\nimport { Appender, Updater, Upsert } from \"./Reducers\";\r\n\r\nexport const useThisDispatcher = (StateName: string, defaultValue: any) => {\r\n  const redux_dispatcher = _MAINSTORE.dispatch;\r\n  const dispatcher = (param: any) => {\r\n    const r = redux_dispatcher(param);\r\n\r\n    // Execute all exisiting effects which is dependent on given state\r\n\r\n    executeEffects(StateName);\r\n    return r;\r\n  };\r\n  const requestedStateName = StateName as keyof StoreState[\"This\"];\r\n  const state_data = _MAINSTORE.getState()?.This;\r\n  if (\r\n    !state_data[requestedStateName] &&\r\n    defaultValue &&\r\n    !getEffects().resolved[requestedStateName]\r\n  ) {\r\n    dispatcher(\r\n      StateHandler.update({\r\n        data: defaultValue,\r\n        state: requestedStateName,\r\n      })\r\n    );\r\n  }\r\n\r\n  const useThisReturn = {\r\n    update: Updater(\r\n      requestedStateName,\r\n      dispatcher\r\n    ) as unknown as useThisReturnType<StoreState[\"This\"]>[\"update\"],\r\n    append: Appender(\r\n      requestedStateName,\r\n      dispatcher\r\n    ) as unknown as useThisReturnType<StoreState[\"This\"]>[\"append\"],\r\n    upsert: Upsert(\r\n      requestedStateName,\r\n      dispatcher\r\n    ) as unknown as useThisReturnType<StoreState[\"This\"]>[\"upsert\"],\r\n    dispatcher: dispatcher,\r\n    This: _MAINSTORE.getState().This[requestedStateName],\r\n    get: () =>\r\n      _MAINSTORE.getState().This[\r\n        requestedStateName\r\n      ] as unknown as useThisReturnType<StoreState[\"This\"]>[\"get\"],\r\n    fetch: () =>\r\n      FunctionManager.fetch(\r\n        _MAINSTORE.getState().This[requestedStateName]\r\n      ) as unknown as useThisReturnType<StoreState[\"This\"]>[\"fetch\"],\r\n  };\r\n\r\n  return useThisReturn as useThisReturnType<StoreState[\"This\"]>;\r\n};\r\nexport const useThisInstanceDispatcher = (StateName: string) => {\r\n  const redux_dispatcher = _MAINSTORE.dispatch;\r\n  const dispatcher = (param: any) => {\r\n    const r = redux_dispatcher(param);\r\n\r\n    // Execute all exisiting effects which is dependent on given state\r\n    executeEffects(StateName);\r\n    return r;\r\n  };\r\n  const requestedStateName = StateName as keyof StoreState[\"This\"];\r\n\r\n  const useThisReturn = {\r\n    update: Updater(\r\n      requestedStateName,\r\n      dispatcher\r\n    ) as unknown as useThisReturnType<StoreState[\"This\"]>[\"update\"],\r\n    append: Appender(\r\n      requestedStateName,\r\n      dispatcher\r\n    ) as unknown as useThisReturnType<StoreState[\"This\"]>[\"append\"],\r\n    upsert: Upsert(\r\n      requestedStateName,\r\n      dispatcher\r\n    ) as unknown as useThisReturnType<StoreState[\"This\"]>[\"upsert\"],\r\n    dispatcher: dispatcher,\r\n    This: _MAINSTORE.getState().This[requestedStateName],\r\n    get: () =>\r\n      _MAINSTORE.getState().This[\r\n        requestedStateName\r\n      ] as unknown as useThisReturnType<StoreState[\"This\"]>[\"get\"],\r\n    fetch: () =>\r\n      FunctionManager.fetch(\r\n        _MAINSTORE.getState().This[requestedStateName]\r\n      ) as unknown as useThisReturnType<StoreState[\"This\"]>[\"fetch\"],\r\n  };\r\n\r\n  return {\r\n    ...useThisReturn,\r\n  } as useThisReturnType<StoreState[\"This\"]>;\r\n};\r\n","import { useSelector } from \"react-redux\";\r\nimport { useThisDispatcher, useThisInstanceDispatcher } from \"../Dispatcher\";\r\nimport { registerEffect } from \"../managers/EffectManager\";\r\nimport { StateHandler } from \"../../redux/slices/StateReducer\";\r\nimport _MAINSTORE, { StoreState } from \"../../redux/store\";\r\nimport {\r\n  useThis_this_instance,\r\n  useThisInstanceType,\r\n  useThisReturnType,\r\n} from \"./useThisTypes\";\r\nexport function useThisInstanceReturn(prop1: unknown) {\r\n  const instance_data: useThis_this_instance = {\r\n    created: false,\r\n    stateName: \"state_\" + Math.floor(100000 + Math.random() * 900000),\r\n  };\r\n\r\n  if (prop1 && typeof prop1 == \"object\") {\r\n    instance_data.defaultData = prop1;\r\n  }\r\n\r\n  const useThisInstance = <T,>() => {\r\n    if (!instance_data.created) {\r\n      throw Error(\"Cannot use useThis Instance without created\");\r\n    }\r\n\r\n    return useThisInstanceFunction<T>(instance_data.stateName);\r\n  };\r\n\r\n  useThisInstance[\"@___usethis\"] = __APP_VERSION__;\r\n  useThisInstance[\"this\"] = instance_data.stateName;\r\n\r\n  useThisInstance.onEffect = (resolver: any, dependent_states: any) => {\r\n    instance_data[\"onEffect\"] = {\r\n      resolver,\r\n      dependent_states,\r\n    };\r\n\r\n    return useThisInstance;\r\n  };\r\n  useThisInstance.stateName = (state_name: string) => {\r\n    instance_data[\"stateName\"] = state_name;\r\n\r\n    return useThisInstance;\r\n  };\r\n  useThisInstance.default = <T extends object>(object: T) => {\r\n    instance_data[\"defaultData\"] = object;\r\n\r\n    return useThisInstance as () => ReturnType<\r\n      typeof useThisInstanceFunction<T>\r\n    >;\r\n  };\r\n\r\n  useThisInstance.setConfig = <T extends keyof useThis_this_instance>(\r\n    config_name: T,\r\n    value: useThis_this_instance[T]\r\n  ) => {\r\n    instance_data[config_name] = value;\r\n    return useThisInstance;\r\n  };\r\n\r\n  useThisInstance.use = {};\r\n\r\n  useThisInstance.create = () => {\r\n    if (instance_data.created) return;\r\n    useThisInstance[\"this\"] = instance_data.stateName;\r\n\r\n    if (instance_data.defaultData) {\r\n      _MAINSTORE.dispatch(\r\n        StateHandler.update({\r\n          data: instance_data.defaultData,\r\n          state: instance_data.stateName,\r\n        })\r\n      );\r\n    }\r\n\r\n    if (instance_data.onEffect) {\r\n      registerEffect({\r\n        state_name: instance_data.stateName,\r\n        dependent_state_names: instance_data.onEffect.dependent_states ?? [],\r\n\r\n        // Effect is stored in effect_collection.effects.{process_id}, This will execute on effect condtion\r\n\r\n        effect: (effectResolver: Function) =>\r\n          instance_data.onEffect?.resolver({\r\n            thisState: _MAINSTORE.getState().This,\r\n            state: (\r\n              state_name:\r\n                | keyof StoreState[\"This\"]\r\n                | (Function & {\r\n                    this: keyof StoreState[\"This\"];\r\n                    \"@___usethis\": unknown;\r\n                  })\r\n            ) => {\r\n              if (typeof state_name == \"function\" && state_name[\"@___usethis\"])\r\n                return _MAINSTORE.getState().This[state_name.this];\r\n              return _MAINSTORE.getState().This[\r\n                state_name as keyof StoreState[\"This\"]\r\n              ];\r\n            },\r\n            resolver: () => {\r\n              _MAINSTORE.dispatch(\r\n                StateHandler.removeState({\r\n                  active_state: instance_data.stateName,\r\n                })\r\n              );\r\n              effectResolver();\r\n\r\n              // instance_data.created = false;\r\n            },\r\n          }),\r\n      });\r\n    }\r\n\r\n    instance_data.created = true;\r\n\r\n    useThisInstance.use = {\r\n      ...(useThisDispatcher(\r\n        instance_data[\"stateName\"],\r\n        instance_data[\"defaultData\"]\r\n      ) as unknown as useThisReturnType<(typeof instance_data)[\"defaultData\"]>),\r\n    } as any;\r\n\r\n    return useThisInstance;\r\n  };\r\n\r\n  return useThisInstance;\r\n}\r\n\r\nfunction useThisInstanceFunction<DefaultValue>(\r\n  StateName: string\r\n): useThisInstanceType<DefaultValue> {\r\n  try {\r\n    useSelector((s: any) => s.This?.[StateName]);\r\n  } catch (e) {}\r\n\r\n  return useThisInstanceDispatcher(\r\n    StateName\r\n  ) as unknown as useThisInstanceType<DefaultValue>;\r\n}\r\n","import { useSelector } from \"react-redux\";\r\nimport { useThisDispatcher } from \"../Dispatcher\";\r\nimport { useThisInstanceReturn } from \"./useThisInstance\";\r\nimport { useThisReturnType, useThisType } from \"./useThisTypes\";\r\n\r\nfunction useThisMainFunction<DefaultValue>(\r\n  StateName: string,\r\n  defaultValue?: DefaultValue\r\n): useThisReturnType<DefaultValue> {\r\n  try {\r\n    useSelector((s: any) => s.This?.[StateName]);\r\n  } catch (e) {}\r\n\r\n  return useThisDispatcher(\r\n    StateName,\r\n    defaultValue\r\n  ) as unknown as useThisReturnType<DefaultValue>;\r\n}\r\n\r\nfunction useThisBuilder(prop1: unknown, prop2: unknown) {\r\n  // Handling new Instance\r\n  if (new.target) {\r\n    return useThisInstanceReturn(prop1);\r\n  }\r\n\r\n  // Rtn useThis as it is\r\n  return useThisMainFunction(prop1 as string, prop2);\r\n}\r\n\r\nexport const useThis: useThisType = useThisBuilder as unknown as useThisType;\r\n"],"names":["function_collection","functionIdCounter","FunctionManager","func","id","obj","acc","key","setFun","value","set","jsSet","effect_collection","registerEffect","props","state_name","effect","dependent_state_names","_a","process_id","dependent_state","_b","executeEffects","resolveEffect","dependent_state_name","item","getEffects","Updater","StateName","dispatcher","data","__DATA","_MAINSTORE","StateHandler","Appender","Upsert","updater","e","upsert","i","keys","new_at_path","useThisDispatcher","defaultValue","redux_dispatcher","param","r","requestedStateName","useThisInstanceDispatcher","useThisInstanceReturn","prop1","instance_data","useThisInstance","useThisInstanceFunction","resolver","dependent_states","object","config_name","effectResolver","useSelector","s","useThisMainFunction","useThisBuilder","prop2","useThis"],"mappings":"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"}